# STACK
## Основная информация об проекте (Этот же проект только на C++ [__клик__](https://github.com/Hollbrok/Stack_cpp_version)).

<a class="github-button" href="https://github.com/Hollbrok" data-show-count="true" aria-label="Follow @Hollbrok on GitHub">Follow</a>

В данном проекте реализована одна из самых основных структур данных __Stack__. Суть этой структуры данных заключается в том, что элементы этой структуры поддерживают принцип __LIFO__ _(“Last in – first out”)_: последним зашёл – первым вышел. Основные функции, с помощью которых мы будем работать со стеком это __push_stack__ и __pop_stack__, примеры их использования будут приведены в самом конце. В реализации так же присутствует многоуровневая защита данных. Защита и грамотная работа __stack__ 'a осуществляется благодаря нескольким простым принципам:
* __Канарейки__ (или же канареечная защита).
* __Hash__ (хэширование данных).
* __Верификатор__ (анализ как достаточно распространенных так и особых случаев, для предотвращения возникновения ошибок или их устранения).

Опять же более подробно об этих принципах будет описано ближе к концу статьи.
Теперь же хочется в кратце показать список (пересказ, если можно так назвать) вещей, которые может наша структура данных.
_______________
- [X] _Полиморфизм_  
    - [X] Тип данных __double__.
    - [X] Тип данных __int__.
    - [X] Тип данных __char__.
    - [X] Тип данных __string__.
    - [X] Тип данных __float__.  
- [X] Структуру _stack_'a.
    - [X] __Канарейки___.
    - [X] Массив типа _type_data_ (в зависимости от типа хранимых данных).
    - [X] Максимальный размер _stack'_ a.
    - [X] Текущий размер _stack'_ a.  
    - [X] __Hash__ _stack'_ a.
- [X] _Конструктор_  _stack'_ a.
    - [X] __Проверки__ на возможные ошибки про вызове конструктора.
        - [X] __Двойной конструктор__.
        - [X] Валидность __максимального размера__  _stack'_ a.
    - [X] Динамическое выделение памяти.
    - [X] Заполнение данныз __POISON'__ ом.
- [X] _Деконструктор_ _stack'_ a.
    - [X] __Проверки__ на возможные ошибки про вызове деконструктора.
        - [X] Полный список находится в описании функции __stack_verify__.
        - [X] __Уровень__ самой проверки варируется в зависимости от требуемого уровня защиты __stack'__ а.  
        - [X] Различные уровни защиты.
            - [X] __LOW__.
            - [X] __MEDIUM__.
            - [X] __HIGH__.
            - [ ] Мега защита, добавляю конструктор копировая.
    - [X] Обеспечение удаления всех данных из стека (_макс._ _размер_, _текущий_ _размер_, _все_ _данные_ _из_ _масива_, _хэша_.)
        - [X] При помощи __POISON__.
    - [X] Освобождение выделенной памяти.
- [X] _push_stack_
    - [X] __Проверки__ на возможные ошибки про вызове функции.
        - [X] Полный список находится в описании функции __stack_verify__.
        - [X] Так же проходит проверка совпадения типов данных и сама проверка __push_number__.
    - [X] Учтено то, что нужно выделять дополнительную память или наоборот освобождать.
        - [X] Написан __реалокатор__.
- [X] _pop_stack_
    - [X] __Проверки__ на возможные ошибки про вызове функции.
        - [X] Полный список находится в описании функции __stack_verify__.
    - [X] Так же учтен тот факт, что нужно увеличивать/уменьшать память, отводимую под хранение данных.
- [X] _stack_dump_
    - [X] Вывод ошибок, если такого существует. И соответственно отсутствие ошибок, если их нет.
    - [X] Вывод всех актуальной информации о стеке.
        - [X] Уровень __защиты данных__.
        - [X] __Имя стека__.
        - [X] __Текущий размер__.
        - [X] __Максимальный размер__.
        - [X] Все __данные__, которые лежат в стеке.
        - [X] Значение __hash__' a _stack'_ a.
        - [X] __Тип данных__, хранимых в _stack'_ e.
    - [X] Учтен тот факт, что данные могут быть разного типа.
- [X] _stack_verify_
    - [X] Проверки
        - [X] __MAX_CAPACITY_ERROR__.
        - [X] __Stack == nullptr__.
        - [X] Проверка на соответствие __hash__ 'a.
        - [X] __stack->data == nullptr__.
        - [X] __Cur_size > max_size__.
        - [X] __Cur_size < 0__.
        - [X] Проверка на валидность значения __max_size__.
        - [X] __Max_size < 0__.
        - [X] Проверка на валидность значения __cur_size__.
        - [X] Проверка на соответствие __канареек__ _stack_ 'a.
        - [X] Проверка на соответствие __канареек__ _stack->data_' ы.
    - [X] В случае ошибки фиксировать ее.
    - [X] Регулировка проверок по уровню защиты
        - [X] __LOW__.
        - [X] __MEDIUM__.
        - [X] __HIGH__.
- [X] _error_print_
    - [X] Возращает __сообщение об ошибки__ в соответсвии с ошибками.
        - [X] Все типы ошибок представлены в _stack_verify_.
- [X] _add_memory_
    - [X] __Проверки__ на возможные ошибки про вызове функции.
        - [X] Полный список находится в описании функции __stack_verify__.
    - [X] Увеличение память на заранее заданную константу __REAL_MULTIPLIER = 2__, если это нужно.
    - [X] Соответственно уменьшение выделенной памяти на заданную константу __REAL_REDUCER = 2 * REAL_MULTIPLIER__ при необходимых условиях.
    - [X] Если начальный размер равен нулю, то размер задается константой __REAL_ADDER__.
    - [X] Все новые данных (или все удаленне) заполняются ___POISON'_ ом.
- [X] _hash_stack_
    - [X] __Проверки__ на возможные ошибки про вызове функции.
        - [X] Полный список находится в описании функции __stack_verify__.
    - [X] Хэширование данных в стеке.
        - [X] Все хранящиеся __данные__.
        - [X] __имя стека__.
        - [X] __Указателей__.
- [X] _define_lvl_
    - [X] Определяет __уровень защиты__ в требованию пользователя.
______________
## Как использовать
### Подключение библиотеки
Так как этот проект превращен в библиотеку, то логичным началом станет показать как правильно включать библиотеку в _ваш проект_.
```c++
    #define DOUBLE_T    
    #include <stack.h>
``` 
Так как __stack__ написан на языке __C__ , то думаю всем понятно, что строчкой перед _#include_ мы даем понять нашему стеку какой тип данных ему необходимо открыть. Сразу становится понятно, что мы не можем создавать стеки, хранящие различные типы данных. В будущей вернии __stack'__ а, который будет зарефакторен на язык __C++__ это неудобство будет убрано и пользователь сможет создавать стеки, хранящие разные типы данных.

В __C__ версии так же существуют еще [4] типа данных, которые поддерживает наш __stack__. Вот как будет выглядеть подключание библиотеки в соответствующих случаях.
```C++
    #define INT_T // stack int'ов    
    #include <stack.h>
``` 
```C++
    #define FLOAT_T // stack float'ов    
    #include <stack.h>
```   
```C++
    #define STRING_T // stack char'ов    
    #include <stack.h>
```   
```c++
    #define CHAR*_T // stack, содержащий строки    
    #include <stack.h>
```   
В нашей реализации было целесообразно добавить разные уровни защиты __stack'__ а.
Всего такох уровней было добавлено __3__, как было видно на схеме в начале. 
1. __High secure__.
2. __Meduim secure__.
3. __Easy secure__.

Аналогично чтобы указать __уровень защиты__ необходимо вместе с предыдущим define' ом прописать соответственно одно из следующих
```c++
    #define HIGH_SECURE   // High security
    // or
    #define MEDIUM_SECURE // Medium security
    // or
    #define LOW_SECURE    // Low security
``` 

В зависимости от уровня защиты скорость работы соответственно __увеличивается/уменьшается__, при __уменьшении/увеличении__ уровня защиты соответственно.

### Как работать с функциями __stack'__ а.
Как подмечалось ранее для работы со структорой данных __stack__ предусмотрено __2__ основных функции: __push__ и __pop__ (как понятно из названия они заносят/достают данные в __stack__ соответственно). Но перед тем как использовать __stack__ необходимо его объявить и проинициализировать. Для первой цели отлично подходит обычное объявление структуры, для второй цели директива препроцессора, она здесь нужна для того, чтобы присвоить __stack'__ у имя, чтобы каким-либо образом различать __stack'__ и между собой.
```C++
    stack_t name = {};
    Construct(name,b) 
```

Опять же приходится делать как-то все не очень обычно, но эти неудобства будут устранены когда __stack__ будет написан на __C++__.
Теперь, когда __stack__ объявлен и проинициализирован мы можем начать работать с ним. Приведем примеры как использовать функции __push__ и __pop__, если тип данных __double__. 
```C++
    push_stack(&Stack, 25.4); // Здесь 25,4 -- push number
    pop_stack(&Stack);        // Достаем число из stack'a.
    // Для случая с данными типа double мы можем присвоить занести число,  
    // которое лежало на верхушке stack'a в другую какуб-нибудь переменную:
    double temp = pop_stack(&Stack);
```
Для просмотра информации (эта функции полезна для пользователя, но особенно для разработчика) существует функция __dump__. Приведем пример ее использования и ее результат для како-либо абстрактной ситуации.
```C++
    stack_dump(&Stack);
```
Результат вывода в файл:

![Результат](https://github.com/Hollbrok/STACK/blob/main/Screenshot_3.png)

В последок стоит упомянуть, что в конце работы со __stack'__ ом необходимо вызывать деконструктор. Необходимость этой исчезнет в __C++__ версии.

### Будущиe плюшки (C++)
В __C++__ версии __stack'__ a будет добавлено:
* Удобное подключение библиотеки
* Так как не будет необходимости указывать тип данных при подключении библиотеки, а так же при помощи средств языке __C++__ у юзера будет возможность создавать __stack'__ и разных типов данных, что станет одним из главных достатков.
* Будет добавлен конструктор по умолчанию и теперь пользователь сможет при объявлении _неявно_ инициализировать стек, без проделывания лишних действий.
* Будет добавлен деконструктор по умолчанию, что так же облегчик работу и повысит удобство использования __stack'__ а.
* Благодаря возмодностям __class'__ ов в языке __C++__ появится возможность сделать публичные и приватные данные в стеке, что уберет необходимость дополнительной защиты данных.
* Так же множество других полезных функций.

    __Coming soon..__

_______
### ~~Ded's weakness~~ cats 😻
______________    
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄.  
⠄⠄⠄⠄⠄⠄⢰⣷⡄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄  
⠄⠄⠄⠄⣠⣾⣿⣿⣷⣦⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄  
⠄⠄⠄⣠⣿⣿⣿⣿⣿⣿⣇⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄  
⠄⠄⠄⠄⠛⠿⣿⣿⣿⣿⣿⣆⠄⠄⠄⠄⠄⣴⣿⣿⣆⠄⠄⠄  
⠄⠄⠄⠄⠄⣰⣿⣿⣿⣿⣿⣿⣷⣄⠄⠄⠄⣿⣿⠛⠉⠄⠄⠄   
⠄⠄⠄⠄⠄⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣄⠄⠘⣿⡆⠄⠄⠄⠄   
⠄⠄⠄⠄⠄⢹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠸⣿⡀⠄⠄⠄  
⠄⠄⠄⠄⠄⠄⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠄⣿⡇⠄⠄⠄  
⠄⠄⠄⠄⠄⠄⢸⣿⡟⣿⣿⣿⣿⣿⣿⣿⣿⡇⢀⣿⠇⠄⠄⠄  
⠄⠄⠄⠄⠄⢀⣸⡿⢁⣘⣿⣿⣿⣿⣿⣿⣿⣇⣼⠋⠄⠄⠄⠄  
⠄⠄⠄⠄⠄⠻⠿⠓⠿⠿⠿⠿⠿⠿⠿⠿⠿⠛⠁⠄⠄⠄⠄⠄  
⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄⠄  
______________________  
.......................／＞　 フ.....................  
　　　　　| 　_　 _ |  
　 　　　／`ミ _x 彡  
　　 　 /　　　 　 |  
　　　 /　 ヽ　　 ﾉ  
　／￣|　　 |　|　|  
　| (￣ヽ____ヽ___)___)  
　＼二つ  
 _____________________
